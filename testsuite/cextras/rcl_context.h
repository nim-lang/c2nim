// Copyright 2018 Open Source Robotics Foundation, Inc.
//

/// @file

#ifndef RCL__CONTEXT_H_
#define RCL__CONTEXT_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include "rmw/init.h"

#include "rcl/allocator.h"
#include "rcl/arguments.h"
#include "rcl/init_options.h"
#include "rcl/macros.h"
#include "rcl/types.h"
#include "rcl/visibility_control.h"

/// A unique ID per context instance.
typedef uint64_t rcl_context_instance_id_t;

typedef struct rcl_context_impl_s rcl_context_impl_t;

/// Encapsulates the non-global state of an init/shutdown cycle.
/**
 * The context is used in the creation of top level entities like nodes and
 * guard conditions, as well as to shutdown a specific instance of init.
 *
 */
typedef struct rcl_context_s
{
  /// Global arguments for all nodes which share this context.
  /** Typically generated by the parsing of argc/argv in rcl_init(). */
  rcl_arguments_t global_arguments;

  /// Implementation specific pointer.
  rcl_context_impl_t * impl;

  // The assumption that this is big enough for an atomic_uint_least64_t is
  // In most cases it should just be a plain uint64_t.
/// @cond Doxygen_Suppress
#if !defined(RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE)
#define RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE sizeof(uint_least64_t)
#endif
/// @endcond
  /// Private storage for instance ID atomic.
  /**
   * Accessing the instance id should be done using the function
   */
  RCL_ALIGNAS(8) uint8_t instance_id_storage[RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE];
} rcl_context_t;

/// Return a zero initialization context object.
RCL_PUBLIC
RCL_WARN_UNUSED
rcl_context_t
rcl_get_zero_initialized_context(void);

/// Finalize a context.
/**
 *
 */
RCL_PUBLIC
RCL_WARN_UNUSED
rcl_ret_t
rcl_context_fini(rcl_context_t * context);

/// Return the init options used during initialization for this context.
/**
 *
 * \param[in] context object from which the init options should be retrieved
 * \return pointer to the the init options, or
 * \return `NULL` if there was an error
 */
RCL_PUBLIC
RCL_WARN_UNUSED
const rcl_init_options_t *
rcl_context_get_init_options(const rcl_context_t * context);

/// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
/**
 */
RCL_PUBLIC
RCL_WARN_UNUSED
rcl_context_instance_id_t
rcl_context_get_instance_id(const rcl_context_t * context);

/// Returns the context domain id.
/**
 */
RCL_PUBLIC
RCL_WARN_UNUSED
rcl_ret_t
rcl_context_get_domain_id(rcl_context_t * context, size_t * domain_id);

/// Return `true` if the given context is currently valid, otherwise `false`.
/**
 * If context is `NULL`, then `false` is returned.
 * If context is zero-initialized, then `false` is returned.
 * If context is uninitialized, then it is undefined behavior.
 *
 */
RCL_PUBLIC
RCL_WARN_UNUSED
bool
rcl_context_is_valid(const rcl_context_t * context);

/// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
/**
 * If context is `NULL`, then `NULL` is returned.
 * If context is zero-initialized, then `NULL` is returned.
 * If context is uninitialized, then it is undefined behavior.
 *
 */
RCL_PUBLIC
RCL_WARN_UNUSED
rmw_context_t *
rcl_context_get_rmw_context(rcl_context_t * context);

#ifdef __cplusplus
}
#endif

#endif  // RCL__CONTEXT_H_
